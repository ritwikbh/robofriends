{"version":3,"sources":["components/Card.js","components/CardList.js","components/SearchBox.js","components/Scroll.js","components/ErrorBoundary.js","containers/App.js","serviceWorker.js","index.js"],"names":["Card","id","name","email","className","alt","src","CardList","cardArray","robots","map","user","key","SearchBox","searchChange","type","placeholder","onChange","Scroll","props","style","overflowY","borderTop","height","children","ErrorBoundary","state","hasError","error","info","this","setState","Component","App","onSearchChange","event","searchField","target","value","fetch","then","response","json","users","filterRobots","filter","robot","toLowerCase","includes","length","React","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","message"],"mappings":"oOA0BeA,EAbF,SAAC,GAAsB,EAArBC,GAAsB,IAAlBC,EAAiB,EAAjBA,KAAMC,EAAW,EAAXA,MACxB,OAEC,yBAAKC,UAAY,uDAChB,yBAAKC,IAAG,UAAOH,EAAP,QAAmBI,IAAG,+BAA2BJ,EAA3B,+BAC9B,6BACC,4BAAKA,GACL,2BAAIC,MCaOI,EA1BE,SAAC,GAAc,IAIzBC,EAJwB,EAAZC,OAIOC,KAAI,SAACC,GAG7B,OACE,kBAAC,EAAD,CAAMC,IAAOD,EAAKV,GAClBA,GAAMU,EAAKV,GACXC,KAAQS,EAAKT,KACbC,MAASQ,EAAKR,WAGjB,OAEC,6BAKEK,ICPWK,EAZG,SAAC,GAAoB,IAAnBC,EAAkB,EAAlBA,aACnB,OACC,yBAAKV,UAAY,OAChB,2BACAA,UAAY,mCACZW,KAAO,SACPC,YAAc,SACdC,SAAYH,MCQAI,G,MAVA,SAACC,GACf,OAIC,yBAAKC,MAAS,CAACC,UAAY,SAAUC,UAAW,kBAAmBC,OAAS,UAC1EJ,EAAMK,YCKKC,E,kDArBd,WAAYN,GAAO,IAAD,8BACjB,cAAMA,IACDO,MAAQ,CACZC,UAAW,GAHK,E,8DAQAC,EAAOC,GACxBC,KAAKC,SAAS,CAACJ,UAAW,M,+BAI1B,OAAGG,KAAKJ,MAAMC,SACN,wDAGDG,KAAKX,MAAMK,a,GAlBQQ,aCsEbC,E,kDAnDd,aAAc,IAAD,8BACZ,gBAiBDC,eAAiB,SAACC,GAEjB,EAAKJ,SAAS,CAACK,YAAcD,EAAME,OAAOC,SAlB1C,EAAKZ,MAAQ,CACZjB,OAAQ,GACR2B,YAAa,IAJF,E,gEAUO,IAAD,OAIlBG,MAAM,8CACLC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,SAAAG,GAAK,OAAI,EAAKZ,SAAS,CAACtB,OAASkC,S,+BAQ/B,IAAD,EACwBb,KAAKJ,MAA7BjB,EADA,EACAA,OAAS2B,EADT,EACSA,YAIVQ,EAAenC,EAAOoC,QAAO,SAAAC,GAClC,OAAOA,EAAM5C,KAAK6C,cAAcC,SAASZ,EAAYW,kBAKtD,OAAQtC,EAAOwC,OAGd,yBAAK7C,UAAY,MAChB,wBAAIA,UAAY,MAAhB,eACA,kBAAC,EAAD,CAAWU,aAAgBgB,KAAKI,iBAChC,kBAAC,EAAD,KACC,kBAAC,EAAD,KACC,kBAAC,EAAD,CAAUzB,OAAUmC,OAPxB,wBAAIxC,UAAY,SAAhB,e,GAtCgB8C,IAAMlB,WCRJmB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,MCXNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDwHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBvB,MAAK,SAAAwB,GACJA,EAAaC,gBAEdC,OAAM,SAAAtC,GACLuC,QAAQvC,MAAMA,EAAMwC,a","file":"static/js/main.8cf67708.chunk.js","sourcesContent":["import React from 'react';\r\n\r\n// This is destructuring. Look at how we split the props parameter into its components in the function arguments.\r\n// And note how all JS expressions are wrapped around in {}\r\n\r\n// NOTE : These are pure components (contain no class, only a function that returns something)\r\n// Data flows from parent to children (ie from Containers with Class to Pure Components in the form of props which define the current state of the\r\n// App. These Pure Components cannot alter the state of the App, only the Parent Containter can, but depending upon the state, these can render\r\n// DOM in a deterministic manner.\r\n// For interactive stuff we'll need to modify the state in the parent. And this is exactly what we do in <App/> which acts as a container\r\n// ie has class, and can modify the state of the app. The state is define by 2 elements here remeber :\r\n// 1. The searchBox\r\n// 2. THe Robots (Cards)\r\nconst Card = ({id, name, email}) => {\r\n\treturn (\r\n\t\t// predefined tachyon classes. grow is the animation.\r\n\t\t<div className = \"tc bg-light-green dib br3 pa3 ma2 grow bw2 shadow-5\">\r\n\t\t\t<img alt = {`${name}.jpg`} src= {`https://robohash.org/${name}?200x200\" alt=\"robots.jpg`}/>\r\n\t\t\t<div>\r\n\t\t\t\t<h2>{name}</h2>\r\n\t\t\t\t<p>{email}</p>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Card;","import React from 'react';\r\nimport Card from './Card';\r\n\r\n//instead of rendering 10's of 100's of cards from the index.js directly, what we can do is to render the parent element of those cards\r\n// ie this CardList that can easily scale by looping through the robots array and creating a list of robot items/cards\r\n\r\n// robots is the destructured props input\r\nconst CardList = ({robots}) => {\r\n\t// we need to return a card Array, where each element looks like this\r\n\t// <Card id = {robots[0].id} name = {robots[0].name} email = {robots[0].email}/>\r\n\t// So run a forEach or better yet, a map loop over the robots array and pick each item and index of it and do the computer.\r\n\tconst cardArray = robots.map((user) => {\r\n\t\t// Note that key is not part of our given parameters, this is just a requirement of React to include a unique key prop in case of arrays\r\n\t\t// so that it track the elements easily in the virtual dom. Make the key something that is unique and won't change. Like the id.\r\n\t\treturn (\r\n\t\t\t\t<Card key = {user.id}\r\n\t\t\t\tid = {user.id}\r\n\t\t\t\tname = {user.name}\r\n\t\t\t\temail = {user.email}/>\r\n\t\t\t\t);\r\n\t});\r\n\treturn  (\r\n\t\t// return the single element to be rendered.\r\n\t\t<div>\r\n\t\t\t{\r\n\t\t\t\t//not that since we're essentially using these brackets to write JS statements, we can also replace the above CardArray loop code\r\n\t\t\t\t//directly in place of the below carArray Variable.\r\n\t\t\t}\r\n\t\t\t{cardArray}\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default CardList;","import React from 'react';\r\n\r\n// This is a pure component too, just like Card\r\n// Props don;t change, they are p0assed down from parent to child component\r\n\r\n// Notice what is happening in the last line of input:\r\n// onChange is simply a listener (JS part) which will look for changes in the SearchBox and whenever a change is detected\r\n// It calls the callback method onSearchChange (which has been passed to this compnonent as a prop named searchChange)\r\n// this will relay information back to our parent (App) to make the necessary changes to the state. \r\nconst SearchBox = ({searchChange}) => {\r\n\treturn (\r\n\t\t<div className = \"pa2\">\r\n\t\t\t<input\r\n\t\t\tclassName = \"pa3 ba b--green bg-lightest-blue\"\r\n\t\t\ttype = 'search'\r\n\t\t\tplaceholder = 'robots'\r\n\t\t\tonChange = {searchChange}/>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default SearchBox;","import React from 'react';\r\n\r\n// the purose of this component is to create a scrollable componenet, like a window, that does not hide the search box when we scroll down\r\n// so instead of the browsr scroll, this becomes a fixed size window that does not hide the header.\r\n// This can then be reused anywhere.\r\n\r\n// TILL NOW WE'SE STUDIED ABOUT:\r\n// 1. PROPS\r\n// 2. STATE\r\n// this is the 3rd concept, ie\r\n// 3. CHILDREN\r\n// Concept used to create components that can wrap other components. Earlier we could only wrap around the small case components like h1 or p in div\r\n// now we'll be able to wrap uppercase custom components (Cards, CardList etc) using the children property,\r\n\r\nconst Scroll = (props) => {\r\n\treturn (\r\n\t\t// Simple adding inline CSS, done here in order to learn the JSX syntax {{}}\r\n\t\t// CSS : overflow-y\r\n\t\t// JSX : overflowY (camelCase)\r\n\t\t<div style = {{overflowY : 'scroll', borderTop: 'solid 1px black', height : '550px'}}>\r\n\t\t\t{props.children}\r\n\t\t</div>\r\n)};\r\n\r\nexport default Scroll;","// works with react 16 or higher\r\nimport React, { Component } from 'react';\r\n\r\nclass ErrorBoundary extends Component {\r\n\tconstructor(props){\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\thasError : false\r\n\t\t}\r\n\t}\r\n\t// Method to change hasError state using a new React 16+ lifecycle method\r\n\t// if anything errors out, this method is called\r\n\tcomponentDidCatch(error, info){\r\n\t\tthis.setState({hasError : true});\r\n\t}\r\n\trender(){\r\n\t\t// if error found then display the contingency. This is mostly not visible during development mode and mostly only in deployment mode.\r\n\t\tif(this.state.hasError){\r\n\t\t\treturn <h1>Uh-Oh. That is not good.</h1>\r\n\t\t}\r\n\t\t// if no error caught then return the children of props/children of this component, which is CardList\r\n\t\treturn this.props.children;\r\n\t}\r\n}\r\n\r\nexport default ErrorBoundary;","import React from 'react';\r\nimport CardList from '../components/CardList';\r\nimport SearchBox from '../components/SearchBox';\r\nimport './App.css';\r\nimport Scroll from '../components/Scroll'\r\nimport ErrorBoundary from '../components/ErrorBoundary';\r\n// we didn't create a new component for h1 obviously but should create one for the search box\r\n// IMP\r\n// This is a Container or a Parent that is capable of modifying the state of the app defined by the entry in SearchBox and the Robots array\r\n// Since this is a container and not a pure component, it cannot be a function, has to be a class with constructor initializing the state of the\r\n// App. State is defined by the items that can change and affect our app. Change in searchField or in the robot array will change our app. So\r\n// these are chosen as state items and passed down to the children in a fixed manner as PROPS (ONE WAY DATA FLOW)\r\n\r\n// How to change the state? That we'll do here with the help of our own function named 'onSearchChange'\r\n// We'll look for change in the search field through SearchBox\r\n// and use that event (change in search field as communicated by the SearchBox component's return value) to filter out our Robots list\r\n// and change the state.\r\n\r\n// Look how the filtering is done: we iterate all the robots one by one and keep only those whose names have the current value of searchField\r\n// as a substring. we return this into a new array and this is assigned to the now modified robots array, thus changing the stete.\r\nclass App extends React.Component {\r\n\t// This has state and is therefore a smart component \r\n\tconstructor(){\r\n\t\tsuper();\r\n\t\tthis.state = {\r\n\t\t\trobots: [],\r\n\t\t\tsearchField: ''\r\n\t\t};\r\n\t}\r\n\r\n\t// this is a lifecycle method, pretty easy stuff but refer to documentation and lecture 214 (part 4)\r\n\t// App is a smart container, contains life cycle HOOKS, state, is a class and not a pure component (method)\r\n\tcomponentDidMount(){\r\n\t\t// if this component has finished mounting to its parent component (root) then run this method.\r\n\t\t// fetch our users list from the api, and convert the response into json. then use this json to update state, set robots to users (json)\r\n\t\t// fetch is part of the window object ...\r\n\t\tfetch('https://jsonplaceholder.typicode.com/users')\r\n\t\t.then(response => response.json())\r\n\t\t.then(users => this.setState({robots : users}));\r\n\t}\r\n\tonSearchChange = (event) => {\r\n\t\t// changing state by changing searchField state of the App based on infor recieved from SeachBox child.\r\n\t\tthis.setState({searchField : event.target.value});\r\n\t}\r\n\t// Note. Remember that for line 60\r\n\t// if we need to pass use 'this' of a child, then we need to use arrow function for that functions definition line above in line 40. IMP.\r\n\trender(){\r\n\t\tconst {robots , searchField} = this.state;\r\n\t\t// changing state. Not literally changing the original varaibale but still each time the searchField changes, we fileter the original\r\n\t\t// array depending on its value to create a new array called filterRobots. Now this is the final array passed to the child called\r\n\t\t// CardList to finally render.\r\n\t\tconst filterRobots = robots.filter(robot => {\r\n\t\t\treturn robot.name.toLowerCase().includes(searchField.toLowerCase());\r\n\t\t});\r\n\r\n\t\t// adding a loading bar (capability only, this is not an actual bar just a simple h1 placeholder)\r\n\t\t// this is used in case the API call takes too much time\r\n\t\treturn !robots.length ?\r\n\t\t<h1 className = 'tc h2'>Loading</h1> :\r\n\t\t(\r\n\t\t\t<div className = 'tc'>\r\n\t\t\t\t<h1 className = 'f2'>ROBOFRIENDS</h1>\r\n\t\t\t\t<SearchBox searchChange = {this.onSearchChange} />\r\n\t\t\t\t<Scroll>\r\n\t\t\t\t\t<ErrorBoundary>\r\n\t\t\t\t\t\t<CardList robots = {filterRobots}/>\r\n\t\t\t\t\t</ErrorBoundary>\r\n\t\t\t\t</Scroll>\r\n\t  \t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './containers/App';\nimport * as serviceWorker from './serviceWorker';\nimport 'tachyons';\n\nReactDOM.render(\n  <React.StrictMode>\n  \t\t<App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}